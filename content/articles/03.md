---
slug: 03-vaxee-a-simpler-fetch-aware-state-manager-for-vue-and-nuxt
title: 'Vaxee: A Simpler, Fetch-Aware State Manager for Vue and Nuxt'
description: A simple dive into the Vaxee state management library for Vue and Nuxt.
date: 2025-10-15
---

When you think of state management in [Vue.js](https://vuejs.org/){target="_blank"} or [Nuxt.js](https://nuxt.com/){target="_blank"}, [**Pinia**](https://pinia.vuejs.org/){target="_blank"} is the go-to library. It’s solid — but when working in Nuxt, managing data fetching and SSR often feels clunky. To keep server/client state in sync, I usually end up mixing [`callOnce()`{lang="ts-type"}](https://nuxt.com/docs/4.x/api/utils/call-once){target="_blank"}, [`useFetch()`{lang="ts-type"}](https://nuxt.com/docs/4.x/api/composables/use-fetch){target="_blank"}, or [`useAsyncData()`{lang="ts-type"}](https://nuxt.com/docs/4.x/api/composables/use-async-data){target="_blank"} in awkward ways.

Recently, I discovered [**Vaxee**](https://vaxee.letstri.dev/){target="_blank"} — a lightweight state manager that treats *fetching* as a first-class concept. It simplifies store logic, server-side fetching, and hydration — all while staying small and intuitive.

---

## What Makes Vaxee Special

Vaxee gives you a compact `createStore()`{lang="ts-type"} factory and three simple primitives:

*   [`state()`{lang="ts-type"}](https://vaxee.letstri.dev/state.html){target="_blank"} — reactive state (like Vue’s [`ref()`{lang="ts-type"}](https://vuejs.org/api/reactivity-core.html#ref){target="_blank"}) with extra options like persistence.
*   [`getter()`{lang="ts-type"}](https://vaxee.letstri.dev/getters.html){target="_blank"} — computed-style derivations (like [`computed()`{lang="ts-type"}](https://vuejs.org/api/reactivity-core.html#computed){target="_blank"}).
*   [`request()`{lang="ts-type"}](https://vaxee.letstri.dev/request.html){target="_blank"} — an async helper with the *feel* of Nuxt’s [`useAsyncData()`{lang="ts-type"}](https://nuxt.com/docs/4.x/api/composables/use-async-data){target="_blank"} but defined directly inside the store.

The magic lies in `request()`{lang="ts-type"}: it keeps fetching logic *inside* the store, exposing helpers like `data`{lang="ts-type"}, `refresh`{lang="ts-type"}, and `status`{lang="ts-type"} for easy use in pages.

## Defining a Store

Vaxee’s API centers around `createStore(name, setup)`{lang="ts-type"}, where all your state, getters, and requests live together.

```ts [stores/user.ts]
import { createStore } from 'vaxee';

export const useUserStore = createStore('user', ({ state, getter, request }) => {
  const tokens = state({ access: '', refresh: '' }, { persist: 'user.tokens' });

  const user = request(({signal}) => $fetch('/api/user', { signal }));

  const fullName = getter(() => user.data.value ? `${user.data.value?.first_name} ${user.data.value?.last_name}` : undefined);

  return { tokens, fullName, user };
});
```

This single file holds everything: state, derived data, and fetch logic.

## The `request()` Advantage

Unlike Pinia, where i often need to take some data fetching logics outside the store, `request()` keeps it internal. Each request exposes:

* `data`{lang="ts-type"}, `error`{lang="ts-type"}, `execute`{lang="ts-type"}, `status`{lang="ts-type"}, `refresh()`{lang="ts-type"} etc for easy use in components and pages.

It even supports parameters:

::code-group

```ts [stores/user.ts]
const user = request<User, { id: number }>(({ signal, params }) =>
  $fetch(`/api/user/${params.id}`, { signal }));
```

```vue [pages/user.vue]
<script setup lang="ts">
const route = useRoute();
const { user: { execute } } = useUserStore();
await execute({ id: route.params.id });
</script>
```
::

## Full Example — Store + Page

::code-group

```ts [stores/user.ts]
import { createStore } from 'vaxee';

export const useUserStore = createStore('user', ({ state, getter, request }) => {
  const tokens = state({ access: '', refresh: '' }, { persist: 'user.tokens' });

  const user = request(({signal}) => $fetch('/api/user', { signal }));

  const fullName = getter(() => user.data.value ? `${user.data.value?.first_name} ${user.data.value?.last_name}` : undefined);

  return { tokens, fullName, user };
});
```

```vue [pages/profile.vue]
<script setup lang="ts">
const { user: { data, execute }, fullName } = useUserStore();
await execute();
</script>

<template>
  <div v-if="data">
    <h1>{{ fullName }}</h1>
    <p>{{ data.email }}</p>
  </div>
</template>
```
::

This setup keeps the fetch logic in the store while the page simply consumes the data.

---

## TL;DR

*   **Pinia**: Reliable, flexible, but fetch coordination in Nuxt can be verbose.
*   **Vaxee**: Minimal and fetch-aware by design.
*   If you want cleaner, colocated state + fetch logic — give [Vaxee](https://vaxee.letstri.dev/){target="_blank"} a try.